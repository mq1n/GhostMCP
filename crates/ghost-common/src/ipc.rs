//! IPC protocol definitions for Host <-> Agent communication
//!
//! The protocol uses a simple length-prefixed JSON format:
//! - 4 bytes: message length (little-endian u32)
//! - N bytes: JSON payload

use crate::Error;
use serde::{Deserialize, Serialize};
use std::io::{Read, Write};

/// Pipe name for Ghost-MCP IPC
pub const PIPE_NAME: &str = r"\\.\pipe\ghost-mcp";

/// Maximum message size (1MB)
pub const MAX_MESSAGE_SIZE: usize = 1024 * 1024;

/// Read a length-prefixed message from a reader
pub fn read_message<R: Read>(reader: &mut R) -> Result<Vec<u8>, Error> {
    let mut len_buf = [0u8; 4];
    reader
        .read_exact(&mut len_buf)
        .map_err(|e| Error::Ipc(format!("Failed to read length: {}", e)))?;

    let len = u32::from_le_bytes(len_buf) as usize;
    if len > MAX_MESSAGE_SIZE {
        return Err(Error::Ipc(format!("Message too large: {} bytes", len)));
    }

    let mut buf = vec![0u8; len];
    reader
        .read_exact(&mut buf)
        .map_err(|e| Error::Ipc(format!("Failed to read body: {}", e)))?;

    Ok(buf)
}

/// Write a length-prefixed message to a writer
pub fn write_message<W: Write>(writer: &mut W, data: &[u8]) -> Result<(), Error> {
    if data.len() > MAX_MESSAGE_SIZE {
        return Err(Error::Ipc(format!(
            "Message too large: {} bytes",
            data.len()
        )));
    }

    let len = (data.len() as u32).to_le_bytes();
    writer
        .write_all(&len)
        .map_err(|e| Error::Ipc(format!("Failed to write length: {}", e)))?;
    writer
        .write_all(data)
        .map_err(|e| Error::Ipc(format!("Failed to write body: {}", e)))?;
    writer
        .flush()
        .map_err(|e| Error::Ipc(format!("Failed to flush: {}", e)))?;

    Ok(())
}

/// Read and deserialize a request
pub fn read_request<R: Read>(reader: &mut R) -> Result<Request, Error> {
    let data = read_message(reader)?;
    serde_json::from_slice(&data).map_err(|e| Error::Ipc(format!("Invalid request JSON: {}", e)))
}

/// Serialize and write a response
pub fn write_response<W: Write>(writer: &mut W, response: &Response) -> Result<(), Error> {
    let data = serde_json::to_vec(response)
        .map_err(|e| Error::Ipc(format!("Failed to serialize response: {}", e)))?;
    write_message(writer, &data)
}

/// Request from host to agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
    pub id: u32,
    pub method: String,
    pub params: serde_json::Value,
}

/// Response from agent to host
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    pub id: u32,
    pub result: ResponseResult,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResponseResult {
    Success(serde_json::Value),
    Error { code: i32, message: String },
}

impl Response {
    pub fn success(id: u32, result: impl Serialize) -> Self {
        Self {
            id,
            result: ResponseResult::Success(
                serde_json::to_value(result).unwrap_or(serde_json::Value::Null),
            ),
        }
    }

    pub fn error(id: u32, code: i32, message: impl Into<String>) -> Self {
        Self {
            id,
            result: ResponseResult::Error {
                code,
                message: message.into(),
            },
        }
    }
}

/// IPC error codes
pub mod error_codes {
    pub const INVALID_REQUEST: i32 = -32600;
    pub const METHOD_NOT_FOUND: i32 = -32601;
    pub const INVALID_PARAMS: i32 = -32602;
    pub const INTERNAL_ERROR: i32 = -32603;
    pub const MEMORY_ACCESS_ERROR: i32 = -32001;
    pub const AUTHORIZATION_DENIED: i32 = -32002;
    pub const NOT_IMPLEMENTED: i32 = -32003;
}

/// Agent status information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentStatus {
    pub version: String,
    pub pid: u32,
    pub process_name: String,
    /// Full path to the process executable
    #[serde(default)]
    pub process_path: Option<String>,
    pub arch: String,
    pub connected: bool,
    /// Number of connected clients (multi-client support)
    #[serde(default)]
    pub client_count: u32,
}

// =============================================================================
// Multi-client Protocol Extensions
// =============================================================================

/// Client identity sent during handshake
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientIdentity {
    /// Client name (e.g., "ghost-core-mcp", "ghost-analysis-mcp")
    pub name: String,
    /// Client version
    pub version: String,
    /// Client capabilities/features requested
    #[serde(default)]
    pub capabilities: Vec<String>,
    /// Unique client session ID (generated by client)
    #[serde(default)]
    pub session_id: String,
}

/// Maximum client name length
pub const MAX_CLIENT_NAME_LENGTH: usize = 128;
/// Maximum capability string length
pub const MAX_CAPABILITY_LENGTH: usize = 64;
/// Maximum capabilities per client
pub const MAX_CAPABILITIES: usize = 32;

impl ClientIdentity {
    pub fn new(name: impl Into<String>, version: impl Into<String>) -> Self {
        let name = name.into();
        let version = version.into();

        // Defensive: truncate if too long
        let name = if name.len() > MAX_CLIENT_NAME_LENGTH {
            name[..MAX_CLIENT_NAME_LENGTH].to_string()
        } else {
            name
        };

        Self {
            name,
            version,
            capabilities: Vec::new(),
            session_id: format!(
                "{:016x}",
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .map(|d| d.as_nanos() as u64)
                    .unwrap_or(0)
            ),
        }
    }

    pub fn with_capability(mut self, cap: impl Into<String>) -> Self {
        if self.capabilities.len() < MAX_CAPABILITIES {
            let cap = cap.into();
            // Truncate capability if too long
            let cap = if cap.len() > MAX_CAPABILITY_LENGTH {
                cap[..MAX_CAPABILITY_LENGTH].to_string()
            } else {
                cap
            };
            self.capabilities.push(cap);
        }
        self
    }

    /// Validate the client identity
    pub fn validate(&self) -> Result<(), String> {
        if self.name.is_empty() {
            return Err("Client name cannot be empty".to_string());
        }
        if self.name.len() > MAX_CLIENT_NAME_LENGTH {
            return Err(format!(
                "Client name too long (max {} chars)",
                MAX_CLIENT_NAME_LENGTH
            ));
        }
        if self.version.is_empty() {
            return Err("Client version cannot be empty".to_string());
        }
        if self.capabilities.len() > MAX_CAPABILITIES {
            return Err(format!("Too many capabilities (max {})", MAX_CAPABILITIES));
        }
        Ok(())
    }
}

/// Handshake response from agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HandshakeResponse {
    /// Whether handshake was accepted
    pub accepted: bool,
    /// Agent status
    pub agent_status: AgentStatus,
    /// Features/capabilities granted to this client
    #[serde(default)]
    pub granted_capabilities: Vec<String>,
    /// Error message if not accepted
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}

/// Event types for the event bus
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum EventType {
    /// Memory was modified
    MemoryWrite,
    /// Breakpoint was hit
    BreakpointHit,
    /// Process state changed (attached, detached, etc.)
    ProcessStateChanged,
    /// Module loaded/unloaded
    ModuleChanged,
    /// Patch was applied
    PatchApplied,
    /// Patch was undone
    PatchUndone,
    /// Safety mode changed
    SafetyModeChanged,
    /// Safety token issued
    SafetyTokenIssued,
    /// Safety token revoked/expired
    SafetyTokenRevoked,
    /// Session attached to process
    SessionAttached,
    /// Session detached from process
    SessionDetached,
    /// Client connected
    ClientConnected,
    /// Client disconnected
    ClientDisconnected,
    /// Script loaded/unloaded
    ScriptChanged,
    /// Hook created/removed
    HookChanged,
    /// Scan completed
    ScanCompleted,
    /// Watch triggered
    WatchTriggered,
    /// Custom event type
    Custom(String),
}

// =============================================================================
// Event Payloads
// =============================================================================

/// Payload for MemoryWrite event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryWritePayload {
    pub address: u64,
    pub size: usize,
    pub client_id: String,
}

/// Payload for PatchApplied event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PatchAppliedPayload {
    pub patch_id: u64,
    pub address: u64,
    pub size: usize,
    pub client_id: String,
}

/// Payload for PatchUndone event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PatchUndonePayload {
    pub patch_id: u64,
    pub address: u64,
    pub client_id: String,
}

/// Payload for SafetyTokenIssued event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyTokenIssuedPayload {
    pub token_id: String,
    pub scope: Capability,
    pub client_id: String,
    pub expires_at: u64,
}

/// Payload for SafetyTokenRevoked event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyTokenRevokedPayload {
    pub token_id: String,
    pub reason: String,
}

/// Payload for SessionAttached event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionAttachedPayload {
    pub pid: u32,
    pub process_name: String,
}

/// Payload for SessionDetached event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionDetachedPayload {
    pub pid: u32,
    pub reason: String,
}

/// Payload for ClientConnected event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientConnectedPayload {
    pub client_id: String,
    pub name: String,
    pub capabilities: Vec<Capability>,
}

/// Payload for ClientDisconnected event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientDisconnectedPayload {
    pub client_id: String,
    pub reason: String,
}

/// Event from agent to subscribed clients
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    /// Event type
    pub event_type: EventType,
    /// Timestamp (millis since epoch)
    pub timestamp: u64,
    /// Source client that triggered the event (if any)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_client: Option<String>,
    /// Event payload
    pub payload: serde_json::Value,
}

impl Event {
    pub fn new(event_type: EventType, payload: impl Serialize) -> Self {
        Self {
            event_type,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .map(|d| d.as_millis() as u64)
                .unwrap_or(0),
            source_client: None,
            payload: serde_json::to_value(payload).unwrap_or(serde_json::Value::Null),
        }
    }

    pub fn with_source(mut self, source: impl Into<String>) -> Self {
        self.source_client = Some(source.into());
        self
    }
}

/// Subscription request for events
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventSubscription {
    /// Event types to subscribe to (empty = all)
    #[serde(default)]
    pub event_types: Vec<EventType>,
    /// Maximum queue size before backpressure
    #[serde(default = "default_queue_size")]
    pub queue_size: usize,
}

fn default_queue_size() -> usize {
    1000
}

impl Default for EventSubscription {
    fn default() -> Self {
        Self {
            event_types: Vec::new(),
            queue_size: default_queue_size(),
        }
    }
}

// =============================================================================
// Shared State Types
// =============================================================================

/// Maximum patch size in bytes
pub const MAX_PATCH_SIZE: usize = 4096;
/// Maximum patch description length
pub const MAX_PATCH_DESCRIPTION_LENGTH: usize = 512;

/// Patch history entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PatchEntry {
    /// Unique patch ID
    pub id: u64,
    /// Address that was patched
    pub address: u64,
    /// Original bytes before patch
    pub original_bytes: Vec<u8>,
    /// New bytes after patch
    pub patched_bytes: Vec<u8>,
    /// Timestamp when patch was applied
    pub timestamp: u64,
    /// Client that applied the patch
    #[serde(skip_serializing_if = "Option::is_none")]
    pub applied_by: Option<String>,
    /// Whether the patch is currently active
    pub active: bool,
    /// Description/reason for patch
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

impl PatchEntry {
    /// Create a new patch entry
    pub fn new(address: u64, original: Vec<u8>, patched: Vec<u8>) -> Self {
        Self {
            id: 0, // Will be set by SharedState
            address,
            original_bytes: original,
            patched_bytes: patched,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .map(|d| d.as_millis() as u64)
                .unwrap_or(0),
            applied_by: None,
            active: true,
            description: None,
        }
    }

    /// Validate the patch entry
    pub fn validate(&self) -> Result<(), String> {
        if self.original_bytes.len() > MAX_PATCH_SIZE {
            return Err(format!(
                "Original bytes too large (max {} bytes)",
                MAX_PATCH_SIZE
            ));
        }
        if self.patched_bytes.len() > MAX_PATCH_SIZE {
            return Err(format!(
                "Patched bytes too large (max {} bytes)",
                MAX_PATCH_SIZE
            ));
        }
        if self.original_bytes.len() != self.patched_bytes.len() {
            return Err("Original and patched bytes must be same length".to_string());
        }
        if let Some(ref desc) = self.description {
            if desc.len() > MAX_PATCH_DESCRIPTION_LENGTH {
                return Err(format!(
                    "Description too long (max {} chars)",
                    MAX_PATCH_DESCRIPTION_LENGTH
                ));
            }
        }
        Ok(())
    }
}

// =============================================================================
// Capability System
// =============================================================================

/// Maximum token ID length
pub const MAX_TOKEN_ID_LENGTH: usize = 64;
/// Maximum operation name length
pub const MAX_OPERATION_LENGTH: usize = 128;
/// Maximum safety token TTL in seconds (24 hours)
pub const MAX_TOKEN_TTL_SECS: u64 = 86400;
/// Default safety token TTL in seconds (5 minutes)
pub const DEFAULT_TOKEN_TTL_SECS: u64 = 300;

/// Capability scopes for method access control
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Capability {
    /// Read-only operations: memory_read, module_list, introspection (default)
    Read,
    /// Write operations: memory_write, exec_write, patch operations
    Write,
    /// Execution operations: exec_call, exec_shellcode, remote_thread
    Execute,
    /// Debug operations: breakpoint_*, thread_suspend/resume, step_*
    Debug,
    /// Admin operations: safety_set_mode, safety_reset, agent_reconnect
    Admin,
}

impl Capability {
    /// Get capability required for a method
    pub fn for_method(method: &str) -> Self {
        match method {
            // Write operations
            m if m.starts_with("memory_write") => Capability::Write,
            m if m.starts_with("patch_") => Capability::Write,
            "exec_write" => Capability::Write,

            // Execute operations
            "exec_call" | "exec_call_api" | "exec_shellcode" => Capability::Execute,
            "remote_thread" | "remote_apc" => Capability::Execute,
            "syscall_invoke" => Capability::Execute,

            // Debug operations
            m if m.starts_with("breakpoint_") => Capability::Debug,
            "thread_suspend" | "thread_resume" => Capability::Debug,
            "execution_step_into" | "execution_continue" => Capability::Debug,

            // Admin operations
            "safety_set_mode" | "safety_reset" => Capability::Admin,
            "agent_reconnect" => Capability::Admin,

            // Default: read
            _ => Capability::Read,
        }
    }

    /// Check if this capability is granted by a set of capabilities
    pub fn is_granted_by(&self, granted: &[Capability]) -> bool {
        // Admin grants all
        if granted.contains(&Capability::Admin) {
            return true;
        }
        granted.contains(self)
    }

    /// Get all capabilities as a vec
    pub fn all() -> Vec<Self> {
        vec![
            Capability::Read,
            Capability::Write,
            Capability::Execute,
            Capability::Debug,
            Capability::Admin,
        ]
    }

    /// Check capability requirement and return error if not granted
    pub fn check(
        required: Capability,
        granted: &[Capability],
        method: &str,
    ) -> std::result::Result<(), String> {
        if required.is_granted_by(granted) {
            Ok(())
        } else {
            Err(format!(
                "Capability '{}' required for method '{}', but only {:?} granted",
                required, method, granted
            ))
        }
    }
}

impl std::fmt::Display for Capability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Capability::Read => write!(f, "read"),
            Capability::Write => write!(f, "write"),
            Capability::Execute => write!(f, "execute"),
            Capability::Debug => write!(f, "debug"),
            Capability::Admin => write!(f, "admin"),
        }
    }
}

impl std::str::FromStr for Capability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "read" => Ok(Capability::Read),
            "write" => Ok(Capability::Write),
            "execute" => Ok(Capability::Execute),
            "debug" => Ok(Capability::Debug),
            "admin" => Ok(Capability::Admin),
            _ => Err(format!("Unknown capability: {}", s)),
        }
    }
}

/// Safety token for operations requiring approval
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyToken {
    /// Token ID
    pub id: String,
    /// Capability scope this token grants
    pub scope: Capability,
    /// Operation that was approved (for audit)
    pub operation: String,
    /// When the token was granted
    pub granted_at: u64,
    /// When the token expires (0 = never)
    pub expires_at: u64,
    /// Client that requested approval
    pub requested_by: String,
    /// Whether token has been used
    #[serde(default)]
    pub used: bool,
}

impl SafetyToken {
    /// Create a new safety token with defensive bounds checking
    pub fn new(
        scope: Capability,
        operation: impl Into<String>,
        requested_by: impl Into<String>,
        ttl_secs: u64,
    ) -> Self {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0);

        // Defensive: truncate operation name if too long
        let mut operation = operation.into();
        if operation.len() > MAX_OPERATION_LENGTH {
            operation.truncate(MAX_OPERATION_LENGTH);
        }

        // Defensive: cap TTL to maximum
        let ttl_secs = ttl_secs.min(MAX_TOKEN_TTL_SECS);

        Self {
            id: format!("tok_{:016x}", now ^ (rand_u64() & 0xFFFFFFFF)),
            scope,
            operation,
            granted_at: now,
            expires_at: if ttl_secs == 0 {
                0
            } else {
                now.saturating_add(ttl_secs)
            },
            requested_by: requested_by.into(),
            used: false,
        }
    }

    /// Check if token is expired
    pub fn is_expired(&self) -> bool {
        if self.expires_at == 0 {
            return false;
        }
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0);
        now > self.expires_at
    }

    /// Check if token is valid for an operation (not expired, not used, correct scope)
    pub fn is_valid_for(&self, required: Capability) -> bool {
        !self.used
            && !self.is_expired()
            && (self.scope == required || self.scope == Capability::Admin)
    }

    /// Validate the token structure
    pub fn validate(&self) -> std::result::Result<(), String> {
        if self.id.is_empty() {
            return Err("Token ID cannot be empty".to_string());
        }
        if self.id.len() > MAX_TOKEN_ID_LENGTH {
            return Err(format!(
                "Token ID too long (max {} chars)",
                MAX_TOKEN_ID_LENGTH
            ));
        }
        if self.operation.len() > MAX_OPERATION_LENGTH {
            return Err(format!(
                "Operation name too long (max {} chars)",
                MAX_OPERATION_LENGTH
            ));
        }
        if self.requested_by.is_empty() {
            return Err("Requested by cannot be empty".to_string());
        }
        Ok(())
    }

    /// Mark token as used (one-time use)
    pub fn mark_used(&mut self) {
        self.used = true;
    }

    /// Get remaining TTL in seconds (0 if expired or no expiry)
    pub fn remaining_ttl(&self) -> u64 {
        if self.expires_at == 0 {
            return 0;
        }
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0);
        self.expires_at.saturating_sub(now)
    }
}

/// Simple pseudo-random for token generation (not cryptographic)
fn rand_u64() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_nanos() as u64)
        .unwrap_or(0)
        .wrapping_mul(6364136223846793005)
        .wrapping_add(1442695040888963407)
}

/// Session metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionMetadata {
    /// Session start time
    pub started_at: u64,
    /// Currently attached process ID (if any)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attached_pid: Option<u32>,
    /// Attached process name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attached_process_name: Option<String>,
    /// When the process was attached
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attached_at: Option<u64>,
    /// Current safety mode
    pub safety_mode: String,
    /// Active script count
    pub active_scripts: u32,
    /// Active hook count
    pub active_hooks: u32,
    /// Loaded module count
    #[serde(default)]
    pub modules_loaded: u32,
    /// Connected client sessions
    pub client_sessions: Vec<ClientSession>,
}

/// Client session information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientSession {
    /// Client ID (session_id from handshake)
    pub client_id: String,
    /// Client name
    pub name: String,
    /// When client connected
    pub connected_at: u64,
    /// Granted capabilities
    pub capabilities: Vec<Capability>,
    /// Last activity timestamp
    pub last_activity: u64,
}

impl Default for SessionMetadata {
    fn default() -> Self {
        Self {
            started_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .map(|d| d.as_millis() as u64)
                .unwrap_or(0),
            attached_pid: None,
            attached_process_name: None,
            attached_at: None,
            safety_mode: "standard".to_string(),
            active_scripts: 0,
            active_hooks: 0,
            modules_loaded: 0,
            client_sessions: Vec::new(),
        }
    }
}

/// Pagination parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Pagination {
    #[serde(default)]
    pub offset: usize,
    #[serde(default = "default_limit")]
    pub limit: usize,
}

fn default_limit() -> usize {
    100
}

impl Default for Pagination {
    fn default() -> Self {
        Self {
            offset: 0,
            limit: default_limit(),
        }
    }
}

/// Paginated response wrapper
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Paginated<T> {
    pub items: Vec<T>,
    pub total: usize,
    pub offset: usize,
    pub limit: usize,
    pub has_more: bool,
}

impl<T> Paginated<T> {
    pub fn new(items: Vec<T>, total: usize, pagination: &Pagination) -> Self {
        let has_more = pagination.offset + items.len() < total;
        Self {
            items,
            total,
            offset: pagination.offset,
            limit: pagination.limit,
            has_more,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Cursor;

    #[test]
    fn test_read_write_message() {
        let data = b"hello world";
        let mut buffer = Vec::new();

        write_message(&mut buffer, data).unwrap();

        let mut reader = Cursor::new(buffer);
        let result = read_message(&mut reader).unwrap();

        assert_eq!(result, data);
    }

    #[test]
    fn test_message_too_large() {
        let data = vec![0u8; MAX_MESSAGE_SIZE + 1];
        let mut buffer = Vec::new();

        let result = write_message(&mut buffer, &data);
        assert!(result.is_err());
    }

    #[test]
    fn test_response_success() {
        let response = Response::success(1, serde_json::json!({"result": "ok"}));
        assert_eq!(response.id, 1);
        match response.result {
            ResponseResult::Success(v) => assert_eq!(v["result"], "ok"),
            _ => panic!("Expected success"),
        }
    }

    #[test]
    fn test_response_error() {
        let response = Response::error(2, -32600, "Invalid request");
        assert_eq!(response.id, 2);
        match response.result {
            ResponseResult::Error { code, message } => {
                assert_eq!(code, -32600);
                assert_eq!(message, "Invalid request");
            }
            _ => panic!("Expected error"),
        }
    }

    #[test]
    fn test_pagination_default() {
        let pagination = Pagination::default();
        assert_eq!(pagination.offset, 0);
        assert_eq!(pagination.limit, 100);
    }

    #[test]
    fn test_paginated_has_more() {
        let pagination = Pagination {
            offset: 0,
            limit: 10,
        };
        let items = vec![1, 2, 3, 4, 5];
        let paginated = Paginated::new(items, 20, &pagination);

        assert!(paginated.has_more);
        assert_eq!(paginated.total, 20);
        assert_eq!(paginated.items.len(), 5);
    }

    #[test]
    fn test_paginated_no_more() {
        let pagination = Pagination {
            offset: 15,
            limit: 10,
        };
        let items = vec![1, 2, 3, 4, 5];
        let paginated = Paginated::new(items, 20, &pagination);

        assert!(!paginated.has_more);
    }

    #[test]
    fn test_request_serialization() {
        let request = Request {
            id: 1,
            method: "test".to_string(),
            params: serde_json::json!({"key": "value"}),
        };

        let json = serde_json::to_string(&request).unwrap();
        let parsed: Request = serde_json::from_str(&json).unwrap();

        assert_eq!(parsed.id, 1);
        assert_eq!(parsed.method, "test");
        assert_eq!(parsed.params["key"], "value");
    }

    // =========================================================================
    // Tests
    // =========================================================================

    #[test]
    fn test_client_identity_new() {
        let identity = ClientIdentity::new("ghost-core-mcp", "0.1.0");
        assert_eq!(identity.name, "ghost-core-mcp");
        assert_eq!(identity.version, "0.1.0");
        assert!(identity.capabilities.is_empty());
        assert!(!identity.session_id.is_empty());
    }

    #[test]
    fn test_client_identity_with_capability() {
        let identity = ClientIdentity::new("test", "1.0")
            .with_capability("events")
            .with_capability("state");
        assert_eq!(identity.capabilities.len(), 2);
        assert!(identity.capabilities.contains(&"events".to_string()));
    }

    #[test]
    fn test_client_identity_truncates_long_name() {
        let long_name = "a".repeat(200);
        let identity = ClientIdentity::new(long_name, "1.0");
        assert_eq!(identity.name.len(), MAX_CLIENT_NAME_LENGTH);
    }

    #[test]
    fn test_client_identity_validate_empty_name() {
        let identity = ClientIdentity {
            name: "".to_string(),
            version: "1.0".to_string(),
            capabilities: vec![],
            session_id: "test".to_string(),
        };
        assert!(identity.validate().is_err());
    }

    #[test]
    fn test_client_identity_validate_empty_version() {
        let identity = ClientIdentity {
            name: "test".to_string(),
            version: "".to_string(),
            capabilities: vec![],
            session_id: "test".to_string(),
        };
        assert!(identity.validate().is_err());
    }

    #[test]
    fn test_client_identity_validate_valid() {
        let identity = ClientIdentity::new("test", "1.0");
        assert!(identity.validate().is_ok());
    }

    #[test]
    fn test_client_identity_max_capabilities() {
        let mut identity = ClientIdentity::new("test", "1.0");
        for i in 0..50 {
            identity = identity.with_capability(format!("cap{}", i));
        }
        // Should be capped at MAX_CAPABILITIES
        assert_eq!(identity.capabilities.len(), MAX_CAPABILITIES);
    }

    #[test]
    fn test_event_type_serialization() {
        let event_type = EventType::MemoryWrite;
        let json = serde_json::to_string(&event_type).unwrap();
        assert_eq!(json, "\"memory_write\"");

        let parsed: EventType = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, EventType::MemoryWrite);
    }

    #[test]
    fn test_event_type_custom() {
        let event_type = EventType::Custom("my_event".to_string());
        let json = serde_json::to_string(&event_type).unwrap();
        let parsed: EventType = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, event_type);
    }

    #[test]
    fn test_event_new() {
        let event = Event::new(
            EventType::PatchApplied,
            serde_json::json!({"address": "0x1000"}),
        );
        assert_eq!(event.event_type, EventType::PatchApplied);
        assert!(event.timestamp > 0);
        assert!(event.source_client.is_none());
    }

    #[test]
    fn test_event_with_source() {
        let event =
            Event::new(EventType::MemoryWrite, serde_json::json!({})).with_source("ghost-core-mcp");
        assert_eq!(event.source_client, Some("ghost-core-mcp".to_string()));
    }

    #[test]
    fn test_event_subscription_default() {
        let sub = EventSubscription::default();
        assert!(sub.event_types.is_empty());
        assert_eq!(sub.queue_size, 1000);
    }

    #[test]
    fn test_patch_entry_new() {
        let patch = PatchEntry::new(0x1000, vec![0x90], vec![0xCC]);
        assert_eq!(patch.address, 0x1000);
        assert_eq!(patch.original_bytes, vec![0x90]);
        assert_eq!(patch.patched_bytes, vec![0xCC]);
        assert!(patch.active);
        assert!(patch.timestamp > 0);
    }

    #[test]
    fn test_patch_entry_validate_valid() {
        let patch = PatchEntry::new(0x1000, vec![0x90], vec![0xCC]);
        assert!(patch.validate().is_ok());
    }

    #[test]
    fn test_patch_entry_validate_size_mismatch() {
        let patch = PatchEntry::new(0x1000, vec![0x90], vec![0xCC, 0xCC]);
        assert!(patch.validate().is_err());
    }

    #[test]
    fn test_patch_entry_validate_too_large() {
        let large = vec![0u8; MAX_PATCH_SIZE + 1];
        let patch = PatchEntry::new(0x1000, large.clone(), large);
        assert!(patch.validate().is_err());
    }

    #[test]
    fn test_handshake_response_serialization() {
        let response = HandshakeResponse {
            accepted: true,
            agent_status: AgentStatus {
                version: "0.1.0".to_string(),
                pid: 1234,
                process_name: "test.exe".to_string(),
                process_path: Some("C:\\test\\test.exe".to_string()),
                arch: "x64".to_string(),
                connected: true,
                client_count: 1,
            },
            granted_capabilities: vec!["events".to_string()],
            error: None,
        };

        let json = serde_json::to_string(&response).unwrap();
        let parsed: HandshakeResponse = serde_json::from_str(&json).unwrap();
        assert!(parsed.accepted);
        assert_eq!(parsed.agent_status.pid, 1234);
    }

    #[test]
    fn test_session_metadata_serialization() {
        let meta = SessionMetadata {
            started_at: 1234567890,
            attached_pid: Some(5678),
            attached_process_name: Some("test.exe".to_string()),
            attached_at: Some(1234567800),
            safety_mode: "normal".to_string(),
            active_scripts: 2,
            active_hooks: 5,
            modules_loaded: 10,
            client_sessions: vec![ClientSession {
                client_id: "sess_123".to_string(),
                name: "ghost-core-mcp".to_string(),
                connected_at: 1234567890,
                capabilities: vec![Capability::Read, Capability::Write],
                last_activity: 1234567890,
            }],
        };

        let json = serde_json::to_string(&meta).unwrap();
        let parsed: SessionMetadata = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.attached_pid, Some(5678));
        assert_eq!(parsed.client_sessions.len(), 1);
        assert_eq!(parsed.client_sessions[0].name, "ghost-core-mcp");
    }

    #[test]
    fn test_safety_token_serialization() {
        let token = SafetyToken {
            id: "tok_123".to_string(),
            scope: Capability::Write,
            operation: "memory_write".to_string(),
            granted_at: 1000,
            expires_at: 2000,
            requested_by: "ghost-core-mcp".to_string(),
            used: false,
        };

        let json = serde_json::to_string(&token).unwrap();
        let parsed: SafetyToken = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.id, "tok_123");
        assert_eq!(parsed.expires_at, 2000);
        assert_eq!(parsed.scope, Capability::Write);
    }

    #[test]
    fn test_safety_token_new() {
        let token = SafetyToken::new(Capability::Write, "patch_apply", "ghost-core-mcp", 300);
        assert!(token.id.starts_with("tok_"));
        assert_eq!(token.scope, Capability::Write);
        assert!(!token.is_expired());
    }

    #[test]
    fn test_capability_for_method() {
        assert_eq!(Capability::for_method("memory_read"), Capability::Read);
        assert_eq!(Capability::for_method("memory_write"), Capability::Write);
        assert_eq!(Capability::for_method("patch_apply"), Capability::Write);
        assert_eq!(Capability::for_method("exec_call"), Capability::Execute);
        assert_eq!(Capability::for_method("breakpoint_set"), Capability::Debug);
        assert_eq!(Capability::for_method("safety_set_mode"), Capability::Admin);
    }

    #[test]
    fn test_capability_is_granted_by() {
        let granted = vec![Capability::Read, Capability::Write];
        assert!(Capability::Read.is_granted_by(&granted));
        assert!(Capability::Write.is_granted_by(&granted));
        assert!(!Capability::Execute.is_granted_by(&granted));

        // Admin grants all
        let admin = vec![Capability::Admin];
        assert!(Capability::Execute.is_granted_by(&admin));
    }

    #[test]
    fn test_capability_from_str() {
        assert_eq!("read".parse::<Capability>().unwrap(), Capability::Read);
        assert_eq!("WRITE".parse::<Capability>().unwrap(), Capability::Write);
        assert!("invalid".parse::<Capability>().is_err());
    }

    #[test]
    fn test_event_payloads_serialization() {
        let payload = MemoryWritePayload {
            address: 0x1000,
            size: 16,
            client_id: "client_1".to_string(),
        };
        let json = serde_json::to_string(&payload).unwrap();
        let parsed: MemoryWritePayload = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.address, 0x1000);

        let payload = PatchAppliedPayload {
            patch_id: 42,
            address: 0x2000,
            size: 4,
            client_id: "client_1".to_string(),
        };
        let json = serde_json::to_string(&payload).unwrap();
        let parsed: PatchAppliedPayload = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.patch_id, 42);
    }

    #[test]
    fn test_safety_token_validate() {
        let token = SafetyToken::new(Capability::Write, "memory_write", "client", 300);
        assert!(token.validate().is_ok());

        // Empty ID should fail
        let mut bad_token = token.clone();
        bad_token.id = "".to_string();
        assert!(bad_token.validate().is_err());

        // Empty requested_by should fail
        let mut bad_token = token.clone();
        bad_token.requested_by = "".to_string();
        assert!(bad_token.validate().is_err());
    }

    #[test]
    fn test_safety_token_mark_used() {
        let mut token = SafetyToken::new(Capability::Write, "test", "client", 300);
        assert!(!token.used);
        assert!(token.is_valid_for(Capability::Write));

        token.mark_used();
        assert!(token.used);
        assert!(!token.is_valid_for(Capability::Write)); // Used tokens are invalid
    }

    #[test]
    fn test_safety_token_remaining_ttl() {
        let token = SafetyToken::new(Capability::Write, "test", "client", 300);
        let remaining = token.remaining_ttl();
        // Should be close to 300, allow some tolerance for test execution time
        assert!(remaining > 290 && remaining <= 300);

        // Token with no expiry
        let no_expiry = SafetyToken::new(Capability::Write, "test", "client", 0);
        assert_eq!(no_expiry.remaining_ttl(), 0);
    }

    #[test]
    fn test_safety_token_ttl_capped() {
        // TTL should be capped at MAX_TOKEN_TTL_SECS
        let token = SafetyToken::new(Capability::Write, "test", "client", 999999);
        let remaining = token.remaining_ttl();
        assert!(remaining <= MAX_TOKEN_TTL_SECS);
    }

    #[test]
    fn test_safety_token_operation_truncated() {
        let long_op = "a".repeat(200);
        let token = SafetyToken::new(Capability::Write, long_op, "client", 300);
        assert!(token.operation.len() <= MAX_OPERATION_LENGTH);
    }

    #[test]
    fn test_capability_check() {
        let granted = vec![Capability::Read, Capability::Write];

        // Should pass
        assert!(Capability::check(Capability::Read, &granted, "memory_read").is_ok());
        assert!(Capability::check(Capability::Write, &granted, "memory_write").is_ok());

        // Should fail
        assert!(Capability::check(Capability::Execute, &granted, "exec_call").is_err());
        assert!(Capability::check(Capability::Admin, &granted, "safety_reset").is_err());
    }

    #[test]
    fn test_capability_all() {
        let all = Capability::all();
        assert_eq!(all.len(), 5);
        assert!(all.contains(&Capability::Read));
        assert!(all.contains(&Capability::Write));
        assert!(all.contains(&Capability::Execute));
        assert!(all.contains(&Capability::Debug));
        assert!(all.contains(&Capability::Admin));
    }
}
